<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Smart Beaver and Resolving Collisions - 洛谷</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="renderer" content="webkit">
<meta name="csrf-token" content="1573391470:o+o0wv9LtMReu48nIo1h7owyeYaVyE5paF/I+YI+ym0=">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" media="screen"/>
<link rel="stylesheet" href="https://cdn.luogu.com.cn/fe/loader.css?ver=20191106">
<script>window._feInjection = JSON.parse(decodeURIComponent("%7B%22code%22%3A200%2C%22currentTemplate%22%3A%22ProblemShow%22%2C%22currentData%22%3A%7B%22problem%22%3A%7B%22background%22%3Anull%2C%22description%22%3A%22The%20Smart%20Beaver%20from%20ABBYY%20has%20a%20lot%20of%20hobbies.%20One%20of%20them%20is%20constructing%20efficient%20hash%20tables.%20One%20of%20the%20most%20serious%20problems%20in%20hash%20tables%20is%20resolving%20collisions.%20The%20Beaver%20is%20interested%20in%20this%20problem%20very%20much%20and%20he%20decided%20to%20explore%20it%20in%20detail.%5Cn%5CnWe%20assume%20that%20the%20hash%20table%20consists%20of%20%24%20h%20%24%20cells%20numbered%20from%20%24%200%20%24%20to%20%24%20h-1%20%24%20.%20Objects%20are%20added%20to%20and%20removed%20from%20it.%20Every%20object%20has%20its%20own%20unique%20identifier.%20In%20addition%2C%20every%20object%20has%20a%20corresponding%20hash%20value%20%5Cu2014%20an%20integer%20between%20%24%200%20%24%20and%20%24%20h-1%20%24%20%2C%20inclusive.%20When%20an%20object%20is%20added%20to%20the%20table%2C%20if%20the%20cell%20corresponding%20to%20the%20hash%20value%20of%20the%20object%20is%20free%2C%20then%20this%20object%20goes%20there.%20If%20the%20cell%20is%20already%20occupied%20by%20another%20object%2C%20there%20is%20a%20collision.%20When%20an%20object%20is%20deleted%20from%20the%20table%2C%20the%20cell%20which%20it%20occupied%20becomes%20empty.%5Cn%5CnThe%20Smart%20Beaver%20has%20recently%20learned%20about%20the%20method%20of%20linear%20probing%20to%20resolve%20collisions.%20It%20is%20as%20follows.%20Let%27s%20say%20that%20the%20hash%20value%20for%20the%20added%20object%20equals%20%24%20t%20%24%20and%20cell%20%24%20t%20%24%20of%20the%20table%20is%20already%20occupied.%20Then%20we%20try%20to%20add%20this%20object%20to%20cell%20%24%20%28t%2Bm%29%5Cu00a0mod%5Cu00a0h%20%24%20.%20If%20it%20is%20also%20occupied%2C%20then%20we%20try%20cell%20%24%20%28t%2B2%5Cu00b7m%29%5Cu00a0mod%5Cu00a0h%20%24%20%2C%20then%20cell%20%24%20%28t%2B3%5Cu00b7m%29%5Cu00a0mod%5Cu00a0h%20%24%20%2C%20and%20so%20on.%20Note%20that%20in%20some%20cases%20it%27s%20possible%20that%20the%20new%20object%20can%20not%20be%20added%20to%20the%20table.%20It%20is%20guaranteed%20that%20the%20input%20for%20this%20problem%20doesn%27t%20contain%20such%20situations.%5Cn%5CnThe%20operation%20%24%20a%5Cu00a0mod%5Cu00a0b%20%24%20means%20that%20we%20take%20the%20remainder%20of%20the%20division%20of%20number%20%24%20a%20%24%20by%20number%20%24%20b%20%24%20.%5Cn%5CnThis%20technique%20immediately%20seemed%20very%20inoptimal%20to%20the%20Beaver%2C%20and%20he%20decided%20to%20assess%20its%20inefficiency.%20So%2C%20you%20are%20given%20a%20sequence%20of%20operations%2C%20each%20of%20which%20is%20either%20an%20addition%20of%20an%20object%20to%20the%20table%20or%20a%20deletion%20of%20an%20object%20from%20the%20table.%20When%20adding%20a%20new%20object%2C%20a%20sequence%20of%20calls%20to%20the%20table%20is%20performed.%20Calls%20to%20occupied%20cells%20are%20called%20dummy.%20In%20other%20words%2C%20if%20the%20result%20of%20the%20algorithm%20described%20above%20is%20the%20object%20being%20added%20to%20cell%20%24%20%28t%2Bi%5Cu00b7m%29%5Cu00a0mod%5Cu00a0h%20%24%20%24%20%28i%3E%3D0%29%20%24%20%2C%20then%20exactly%20%24%20i%20%24%20dummy%20calls%20have%20been%20performed.%5Cn%5CnYour%20task%20is%20to%20calculate%20the%20total%20number%20of%20dummy%20calls%20to%20the%20table%20for%20the%20given%20sequence%20of%20additions%20and%20deletions.%20When%20an%20object%20is%20deleted%20from%20the%20table%2C%20assume%20that%20no%20dummy%20calls%20are%20performed.%20The%20table%20is%20empty%20before%20performing%20the%20operations%2C%20that%20is%2C%20initially%20it%20doesn%27t%20contain%20any%20objects.%22%2C%22inputFormat%22%3A%22The%20first%20line%20of%20input%20contains%20three%20integers%20%24%20h%20%24%20%2C%20%24%20m%20%24%20and%20%24%20n%20%24%20%28%20%24%201%3C%3Dm%3Ch%20%24%20%29%2C%20separated%20by%20spaces%2C%20where%20%24%20h%20%24%20is%20the%20size%20of%20the%20hash%20table%2C%20%24%20m%20%24%20is%20the%20number%20that%20is%20used%20to%20resolve%20collisions%2C%20%24%20n%20%24%20is%20the%20number%20of%20operations.%5Cn%5CnThe%20following%20%24%20n%20%24%20lines%20contains%20the%20descriptions%20of%20the%20operations.%20Their%20execution%20order%20corresponds%20to%20the%20order%20in%20which%20they%20appear%20in%20the%20input%20file.%20Each%20operation%20is%20described%20by%20a%20single%20line.%20The%20operations%20are%20described%20as%20follows%3A%5Cn%5Cn-%20%5C%22%2B%20id%20hash%5C%22This%20is%20the%20format%20of%20the%20operation%20that%20adds%20an%20object%20to%20the%20table.%20The%20first%20character%20is%20%5C%22%2B%5C%22%20%28ASCII%2043%29%2C%20followed%20by%20a%20single%20space%2C%20then%20the%20object%20identifier%20%24%20id%20%24%20%24%20%280%3C%3Did%3C%3D10%5E%7B9%7D%29%20%24%20%2C%20then%20another%20space%2C%20and%20the%20hash%20value%20of%20the%20given%20object%20%24%20hash%20%24%20%24%20%280%3C%3Dhash%3Ch%29%20%24%20.%20The%20object%20identifier%20and%20the%20hash%20value%20of%20this%20object%20are%20integers.%5Cn-%20%5C%22-%20id%5C%22This%20is%20the%20format%20of%20the%20operation%20that%20deletes%20an%20object%20from%20the%20table.%20The%20first%20character%20is%20%5C%22-%5C%22%20%28ASCII%2045%29%2C%20followed%20by%20a%20single%20space%2C%20then%20the%20object%20identifier%20%24%20id%20%24%20%24%20%280%3C%3Did%3C%3D10%5E%7B9%7D%29%20%24%20.%20The%20object%20identifier%20is%20an%20integer.%5Cn%5CnIt%20is%20guaranteed%20that%20for%20all%20addition%20operations%20the%20value%20of%20%24%20id%20%24%20is%20unique.%20It%20is%20also%20guaranteed%20that%20the%20initial%20data%20is%20correct%2C%20that%20is%2C%20it%27s%20always%20possible%20to%20add%20an%20object%20to%20the%20hash%20table%20and%20there%20won%27t%20be%20any%20deletions%20of%20nonexisting%20objects.%5Cn%5CnThe%20input%20limitations%20for%20getting%2020%20points%20are%3A%5Cn%5Cn-%20%24%201%3C%3Dh%3C%3D5000%20%24%5Cn-%20%24%201%3C%3Dn%3C%3D5000%20%24%5Cn%5CnThe%20input%20limitations%20for%20getting%2050%20points%20are%3A%5Cn%5Cn-%20%24%201%3C%3Dh%3C%3D5%5Cu00b710%5E%7B4%7D%20%24%5Cn-%20%24%201%3C%3Dn%3C%3D5%5Cu00b710%5E%7B4%7D%20%24%5Cn%5CnThe%20input%20limitations%20for%20getting%20100%20points%20are%3A%5Cn%5Cn-%20%24%201%3C%3Dh%3C%3D2%5Cu00b710%5E%7B5%7D%20%24%5Cn-%20%24%201%3C%3Dn%3C%3D2%5Cu00b710%5E%7B5%7D%20%24%22%2C%22outputFormat%22%3A%22Print%20a%20single%20number%20%5Cu2014%20the%20total%20number%20of%20dummy%20calls%20to%20the%20hash%20table.%5Cn%5CnPlease%2C%20do%20not%20use%20the%20%25lld%20specifier%20to%20read%20or%20write%2064-bit%20integers%20in%20%5Cu0421%2B%2B.%20It%20is%20preferred%20to%20use%20cin%2C%20cout%20streams%20and%20the%20%25I64d%20specifier.%22%2C%22samples%22%3A%5B%5B%2210%202%207%5Cn%2B%2011%200%5Cn%2B%2022%202%5Cn%2B%2033%206%5Cn%2B%2044%200%5Cn%2B%2055%200%5Cn-%2022%5Cn%2B%2066%200%5Cn%22%2C%227%5Cn%22%5D%2C%5B%225%201%206%5Cn%2B%20123%200%5Cn%2B%20234%201%5Cn%2B%20345%202%5Cn-%20234%5Cn%2B%20456%200%5Cn%2B%20567%200%5Cn%22%2C%224%5Cn%22%5D%5D%2C%22hint%22%3A%22%22%2C%22provider%22%3A%7B%22uid%22%3A3%2C%22name%22%3A%22%5Cu6d1b%5Cu8c37%22%2C%22slogan%22%3A%22%22%2C%22badge%22%3A%22%22%2C%22isAdmin%22%3Atrue%2C%22color%22%3A%22Purple%22%2C%22ccfLevel%22%3A0%7D%2C%22canEdit%22%3Afalse%2C%22limits%22%3A%7B%22time%22%3A%5B1000%5D%2C%22memory%22%3A%5B256000%5D%7D%2C%22stdCode%22%3A%22%22%2C%22vjudge%22%3A%7B%22origin%22%3A%22CodeForces%22%2C%22link%22%3A%22http%3A%5C%2F%5C%2Fcodeforces.com%5C%2Fproblemset%5C%2Fproblem%5C%2F178%5C%2FC1%22%2C%22id%22%3A%22178C1%22%7D%2C%22tags%22%3A%5B%5D%2C%22wantsTranslation%22%3Atrue%2C%22totalSubmit%22%3A0%2C%22totalAccepted%22%3A0%2C%22pid%22%3A%22CF178C1%22%2C%22title%22%3A%22Smart%20Beaver%20and%20Resolving%20Collisions%22%2C%22difficulty%22%3A0%2C%22type%22%3A%22CF%22%7D%2C%22contest%22%3Anull%2C%22discussions%22%3A%5B%5D%2C%22bookmarked%22%3Afalse%2C%22vjudgeUsername%22%3Anull%2C%22recommendations%22%3A%5B%5D%2C%22lastLanguage%22%3A%22%22%2C%22lastCode%22%3A%22%22%7D%2C%22currentTitle%22%3A%22Smart%20Beaver%20and%20Resolving%20Collisions%22%2C%22currentTheme%22%3Anull%7D"));window._feConfigVersion=1573286098;</script>
<script src="https://cdn.luogu.com.cn/fe/loader.js?ver=20191106" charset="utf-8" defer></script>
</head>
<body>
<div id="app">
<div class="lg-container">
<article>
<h1>Smart Beaver and Resolving Collisions</h1>
<h2>题目描述</h2>
<div>The Smart Beaver from ABBYY has a lot of hobbies. One of them is constructing efficient hash tables. One of the most serious problems in hash tables is resolving collisions. The Beaver is interested in this problem very much and he decided to explore it in detail.
We assume that the hash table consists of $ h $ cells numbered from $ 0 $ to $ h-1 $ . Objects are added to and removed from it. Every object has its own unique identifier. In addition, every object has a corresponding hash value — an integer between $ 0 $ and $ h-1 $ , inclusive. When an object is added to the table, if the cell corresponding to the hash value of the object is free, then this object goes there. If the cell is already occupied by another object, there is a collision. When an object is deleted from the table, the cell which it occupied becomes empty.
The Smart Beaver has recently learned about the method of linear probing to resolve collisions. It is as follows. Let's say that the hash value for the added object equals $ t $ and cell $ t $ of the table is already occupied. Then we try to add this object to cell $ (t+m) mod h $ . If it is also occupied, then we try cell $ (t+2·m) mod h $ , then cell $ (t+3·m) mod h $ , and so on. Note that in some cases it's possible that the new object can not be added to the table. It is guaranteed that the input for this problem doesn't contain such situations.
The operation $ a mod b $ means that we take the remainder of the division of number $ a $ by number $ b $ .
This technique immediately seemed very inoptimal to the Beaver, and he decided to assess its inefficiency. So, you are given a sequence of operations, each of which is either an addition of an object to the table or a deletion of an object from the table. When adding a new object, a sequence of calls to the table is performed. Calls to occupied cells are called dummy. In other words, if the result of the algorithm described above is the object being added to cell $ (t+i·m) mod h $ $ (i>=0) $ , then exactly $ i $ dummy calls have been performed.
Your task is to calculate the total number of dummy calls to the table for the given sequence of additions and deletions. When an object is deleted from the table, assume that no dummy calls are performed. The table is empty before performing the operations, that is, initially it doesn't contain any objects.</div>
<h2>输入输出格式</h2>
<h3>输入格式</h3>
<br />
<div>The first line of input contains three integers $ h $ , $ m $ and $ n $ ( $ 1<=m<h $ ), separated by spaces, where $ h $ is the size of the hash table, $ m $ is the number that is used to resolve collisions, $ n $ is the number of operations. The following $ n $ lines contains the descriptions of the operations. Their execution order corresponds to the order in which they appear in the input file. Each operation is described by a single line. The operations are described as follows: - "+ id hash"This is the format of the operation that adds an object to the table. The first character is "+" (ASCII 43), followed by a single space, then the object identifier $ id $ $ (0<=id<=10^{9}) $ , then another space, and the hash value of the given object $ hash $ $ (0<=hash<h) $ . The object identifier and the hash value of this object are integers. - "- id"This is the format of the operation that deletes an object from the table. The first character is "-" (ASCII 45), followed by a single space, then the object identifier $ id $ $ (0<=id<=10^{9}) $ . The object identifier is an integer. It is guaranteed that for all addition operations the value of $ id $ is unique. It is also guaranteed that the initial data is correct, that is, it's always possible to add an object to the hash table and there won't be any deletions of nonexisting objects. The input limitations for getting 20 points are: - $ 1<=h<=5000 $ - $ 1<=n<=5000 $ The input limitations for getting 50 points are: - $ 1<=h<=5·10^{4} $ - $ 1<=n<=5·10^{4} $ The input limitations for getting 100 points are: - $ 1<=h<=2·10^{5} $ - $ 1<=n<=2·10^{5} $</div>
<h3>输出格式</h3>
<br />
<div>Print a single number — the total number of dummy calls to the hash table.
Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams and the %I64d specifier.</div>
<h2>输入输出样例</h2>
<h3>输入样例 #1</h3>
<pre><code>10 2 7
+ 11 0
+ 22 2
+ 33 6
+ 44 0
+ 55 0
- 22
+ 66 0
</code></pre>
<h3>输出样例 #1</h3>
<pre><code>7
</code></pre>
<h3>输入样例 #2</h3>
<pre><code>5 1 6
+ 123 0
+ 234 1
+ 345 2
- 234
+ 456 0
+ 567 0
</code></pre>
<h3>输出样例 #2</h3>
<pre><code>4
</code></pre>
</article>
</div>
</div>
</body>
</html>
