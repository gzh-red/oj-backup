<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Broken BST - 洛谷</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="renderer" content="webkit">
<meta name="csrf-token" content="1573397995:8xO5O9FgyG5IHP+5lcJzOs1RkwlaeC8xDNgTSyowUUE=">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" media="screen"/>
<link rel="stylesheet" href="https://cdn.luogu.com.cn/fe/loader.css?ver=20191106">
<script>window._feInjection = JSON.parse(decodeURIComponent("%7B%22code%22%3A200%2C%22currentTemplate%22%3A%22ProblemShow%22%2C%22currentData%22%3A%7B%22problem%22%3A%7B%22background%22%3A%22%22%2C%22description%22%3A%22Let%20%24%20T%20%24%20be%20arbitrary%20binary%20tree%20%5Cu2014%20tree%2C%20every%20vertex%20of%20which%20has%20no%20more%20than%20two%20children.%20Given%20tree%20is%20rooted%2C%20so%20there%20exists%20only%20one%20vertex%20which%20doesn%27t%20have%20a%20parent%20%5Cu2014%20it%27s%20the%20root%20of%20a%20tree.%20Every%20vertex%20has%20an%20integer%20number%20written%20on%20it.%20Following%20algorithm%20is%20run%20on%20every%20value%20from%20the%20tree%20%24%20T%20%24%20%3A%5Cn%5Cn1.%20Set%20pointer%20to%20the%20root%20of%20a%20tree.%5Cn2.%20Return%20success%20if%20the%20value%20in%20the%20current%20vertex%20is%20equal%20to%20the%20number%20you%20are%20looking%20for%5Cn3.%20Go%20to%20the%20left%20child%20of%20the%20vertex%20if%20the%20value%20in%20the%20current%20vertex%20is%20greater%20than%20the%20number%20you%20are%20looking%20for%5Cn4.%20Go%20to%20the%20right%20child%20of%20the%20vertex%20if%20the%20value%20in%20the%20current%20vertex%20is%20less%20than%20the%20number%20you%20are%20looking%20for%5Cn5.%20Return%20fail%20if%20you%20try%20to%20go%20to%20the%20vertex%20that%20doesn%27t%20exist%5Cn%5CnHere%20is%20the%20pseudo-code%20of%20the%20described%20algorithm%3A%5Cn%5Cn%60%3Cbr%3E%3C%5C%2Fbr%3Ebool%20find%28TreeNode%20t%2C%20int%20x%29%20%7B%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20if%20%28t%20%3D%3D%20null%29%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20return%20false%3B%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20if%20%28t.value%20%3D%3D%20x%29%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20return%20true%3B%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20if%20%28x%20%3C%20t.value%29%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20return%20find%28t.left%2C%20x%29%3B%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20else%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20return%20find%28t.right%2C%20x%29%3B%3Cbr%3E%3C%5C%2Fbr%3E%7D%3Cbr%3E%3C%5C%2Fbr%3Efind%28root%2C%20x%29%3B%3Cbr%3E%3C%5C%2Fbr%3E%60The%20described%20algorithm%20works%20correctly%20if%20the%20tree%20is%20binary%20search%20tree%20%28i.e.%20for%20each%20node%20the%20values%20of%20left%20subtree%20are%20less%20than%20the%20value%20in%20the%20node%2C%20the%20values%20of%20right%20subtree%20are%20greater%20than%20the%20value%20in%20the%20node%29.%20But%20it%20can%20return%20invalid%20result%20if%20tree%20is%20not%20a%20binary%20search%20tree.%5Cn%5CnSince%20the%20given%20tree%20is%20not%20necessarily%20a%20binary%20search%20tree%2C%20not%20all%20numbers%20can%20be%20found%20this%20way.%20Your%20task%20is%20to%20calculate%2C%20how%20many%20times%20the%20search%20will%20fail%20being%20running%20on%20every%20value%20from%20the%20tree.%5Cn%5CnIf%20the%20tree%20has%20multiple%20vertices%20with%20the%20same%20values%20on%20them%20then%20you%20should%20run%20algorithm%20on%20every%20one%20of%20them%20separately.%22%2C%22inputFormat%22%3A%22First%20line%20contains%20integer%20number%20%24%20n%20%24%20%28%20%24%201%3C%3Dn%3C%3D10%5E%7B5%7D%20%24%20%29%20%5Cu2014%20number%20of%20vertices%20in%20the%20tree.%5Cn%5CnEach%20of%20the%20next%20%24%20n%20%24%20lines%20contains%20%24%203%20%24%20numbers%20%24%20v%20%24%20%2C%20%24%20l%20%24%20%2C%20%24%20r%20%24%20%28%20%24%200%3C%3Dv%3C%3D10%5E%7B9%7D%20%24%20%29%20%5Cu2014%20value%20on%20current%20vertex%2C%20index%20of%20the%20left%20child%20of%20the%20vertex%20and%20index%20of%20the%20right%20child%20of%20the%20vertex%2C%20respectively.%20If%20some%20child%20doesn%27t%20exist%20then%20number%20%24%20-1%20%24%20is%20set%20instead.%20Note%20that%20different%20vertices%20of%20the%20tree%20may%20contain%20the%20same%20values.%22%2C%22outputFormat%22%3A%22Print%20number%20of%20times%20when%20search%20algorithm%20will%20fail.%22%2C%22samples%22%3A%5B%5B%223%5Cn15%20-1%20-1%5Cn10%201%203%5Cn5%20-1%20-1%5Cn%22%2C%222%5Cn%22%5D%2C%5B%228%5Cn6%202%203%5Cn3%204%205%5Cn12%206%207%5Cn1%20-1%208%5Cn4%20-1%20-1%5Cn5%20-1%20-1%5Cn14%20-1%20-1%5Cn2%20-1%20-1%5Cn%22%2C%221%5Cn%22%5D%5D%2C%22hint%22%3A%22In%20the%20example%20the%20root%20of%20the%20tree%20in%20vertex%20%24%202%20%24%20.%20Search%20of%20numbers%20%24%205%20%24%20and%20%24%2015%20%24%20will%20return%20fail%20because%20on%20the%20first%20step%20algorithm%20will%20choose%20the%20subtree%20which%20doesn%27t%20contain%20numbers%20you%20are%20looking%20for.%22%2C%22provider%22%3A%7B%22uid%22%3A3%2C%22name%22%3A%22%5Cu6d1b%5Cu8c37%22%2C%22slogan%22%3A%22%22%2C%22badge%22%3A%22%22%2C%22isAdmin%22%3Atrue%2C%22color%22%3A%22Purple%22%2C%22ccfLevel%22%3A0%7D%2C%22canEdit%22%3Afalse%2C%22limits%22%3A%7B%22time%22%3A%5B1000%5D%2C%22memory%22%3A%5B256000%5D%7D%2C%22stdCode%22%3A%22%22%2C%22vjudge%22%3A%7B%22origin%22%3A%22CodeForces%22%2C%22link%22%3A%22http%3A%5C%2F%5C%2Fcodeforces.com%5C%2Fproblemset%5C%2Fproblem%5C%2F797%5C%2FD%22%2C%22id%22%3A%22797D%22%7D%2C%22translation%22%3A%22%60%60%60%5Cn%2A%2A%5Cu9898%5Cu610f%3A%2A%2A%20%20%20%5Cn%5Ct%5Cu7ed9%5Cu4e00%5Cu68f5%5Cu4e8c%5Cu53c9%5Cu641c%5Cu7d22%5Cu6811%2C%5Cu4f46%5Cu662f%5Cu4e0d%5Cu4fdd%5Cu8bc1%5Cu8fd9%5Cu662f%5Cu4e00%5Cu68f5%5Cu6b63%5Cu786e%5Cu7684%5Cu4e8c%5Cu53c9%5Cu641c%5Cu7d22%5Cu6811%2C%5Cu90a3%5Cu4e48%5Cu6309%5Cu7167%5Cu4e8c%5Cu53c9%5Cu641c%5Cu7d22%5Cu6811%5Cu7684%5Cu641c%5Cu7d22%5Cu7b97%5Cu6cd5%28%5Cu5c0f%5Cu5f80%5Cu5de6%2C%5Cu5927%5Cu5f80%5Cu53f3%29%2C%5Cu53ef%5Cu80fd%5Cu627e%5Cu4e0d%5Cu5230%5Cu67d0%5Cu4e9b%5Cu8282%5Cu70b9%2C%5Cu4f60%5Cu7684%5Cu4efb%5Cu52a1%5Cu662f%5Cu8ba1%5Cu7b97%5Cu6709%5Cu591a%5Cu5c11%5Cu8282%5Cu70b9%5Cu5c06%5Cu4e0d%5Cu4f1a%5Cu88ab%5Cu904d%5Cu5386%5Cu5230.%20%20%5Cn%2A%2A%5Cu8f93%5Cu5165%3A%2A%2A%20%20%20%5Cn%5Ct%5Cu7b2c%5Cu4e00%5Cu884c%5Cu4e00%5Cu4e2a%5Cu6574%5Cu6570n%281%3C%3Dn%3C%3D100000%29%5Cu8868%5Cu793a%5Cu8282%5Cu70b9%5Cu6570%5Cu76ee%20%20%5Cn%5Ct%5Cu63a5%5Cu4e0b%5Cu6765n%5Cu884c%5Cu6bcf%5Cu884c%5Cu4e09%5Cu4e2a%5Cu6574%5Cu6570v%280%3C%3Dv%3C%3D10%5E9%29%2Cl%2Cr%2C%5Cu5206%5Cu522b%5Cu8868%5Cu793a%5Cu8282%5Cu70b9%5Cu503c%2C%5Cu5de6%5Cu5b69%5Cu5b50%5Cu548c%5Cu53f3%5Cu5b69%5Cu5b50%5Cu7684%5Cu7f16%5Cu53f7%2C%5Cu6ce8%5Cu610f%5Cu82e5%5Cu8be5%5Cu5b50%5Cu8282%5Cu70b9%5Cu4e0d%5Cu5b58%5Cu5728%5Cu7528-1%5Cu8868%5Cu793a%2C%5Cu4e0d%5Cu540c%5Cu8282%5Cu70b9%5Cu7684%5Cu503c%5Cu53ef%5Cu80fd%5Cu76f8%5Cu540c%20%20%5Cn%2A%2A%5Cu8f93%5Cu51fa%3A%2A%2A%20%20%20%5Cn%5Ct%5Cu627e%5Cu4e0d%5Cu5230%5Cu7684%5Cu8282%5Cu70b9%5Cu6709%5Cu591a%5Cu5c11%5Cu4e2a%5Cn%60%60%60%5Cn%5Cu8d21%5Cu732e%5Cu8005%5Cuff1a%5Cu51cc%5Cu5e7d%22%2C%22tags%22%3A%5B%5D%2C%22wantsTranslation%22%3Afalse%2C%22totalSubmit%22%3A62%2C%22totalAccepted%22%3A21%2C%22pid%22%3A%22CF797D%22%2C%22title%22%3A%22Broken%20BST%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%22contest%22%3Anull%2C%22discussions%22%3A%5B%7B%22id%22%3A32783%2C%22title%22%3A%22%5Cu7ffb%5Cu8bd1%22%2C%22forum%22%3A%7B%22id%22%3A9404%2C%22name%22%3A%22CF797D%20Broken%20BST%22%2C%22slug%22%3A%22CF797D%22%7D%7D%5D%2C%22bookmarked%22%3Afalse%2C%22vjudgeUsername%22%3Anull%2C%22recommendations%22%3A%5B%7B%22pid%22%3A%22P1446%22%2C%22title%22%3A%22%5BHNOI2008%5DCards%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22P%22%7D%2C%7B%22pid%22%3A%22P2464%22%2C%22title%22%3A%22%5BSDOI2008%5D%5Cu90c1%5Cu95f7%5Cu7684%5Cu5c0fJ%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22P%22%7D%2C%7B%22pid%22%3A%22CF797F%22%2C%22title%22%3A%22Mice%20and%20Holes%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF797E%22%2C%22title%22%3A%22Array%20Queries%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF1025D%22%2C%22title%22%3A%22Recovering%20BST%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%5D%2C%22lastLanguage%22%3A%22%22%2C%22lastCode%22%3A%22%22%7D%2C%22currentTitle%22%3A%22Broken%20BST%22%2C%22currentTheme%22%3Anull%7D"));window._feConfigVersion=1572920822;</script>
<script src="https://cdn.luogu.com.cn/fe/loader.js?ver=20191106" charset="utf-8" defer></script>
</head>
<body>
<div id="app">
<div class="lg-container">
<article>
<h1>Broken BST</h1>
<h2>题意翻译</h2>
<div>```
**题意:**
给一棵二叉搜索树,但是不保证这是一棵正确的二叉搜索树,那么按照二叉搜索树的搜索算法(小往左,大往右),可能找不到某些节点,你的任务是计算有多少节点将不会被遍历到.
**输入:**
第一行一个整数n(1<=n<=100000)表示节点数目
接下来n行每行三个整数v(0<=v<=10^9),l,r,分别表示节点值,左孩子和右孩子的编号,注意若该子节点不存在用-1表示,不同节点的值可能相同
**输出:**
找不到的节点有多少个
```
贡献者：凌幽</div>
<h2>题目描述</h2>
<div>Let $ T $ be arbitrary binary tree — tree, every vertex of which has no more than two children. Given tree is rooted, so there exists only one vertex which doesn't have a parent — it's the root of a tree. Every vertex has an integer number written on it. Following algorithm is run on every value from the tree $ T $ :
1. Set pointer to the root of a tree.
2. Return success if the value in the current vertex is equal to the number you are looking for
3. Go to the left child of the vertex if the value in the current vertex is greater than the number you are looking for
4. Go to the right child of the vertex if the value in the current vertex is less than the number you are looking for
5. Return fail if you try to go to the vertex that doesn't exist
Here is the pseudo-code of the described algorithm:
`<br></br>bool find(TreeNode t, int x) {<br></br> if (t == null)<br></br> return false;<br></br> if (t.value == x)<br></br> return true;<br></br> if (x < t.value)<br></br> return find(t.left, x);<br></br> else<br></br> return find(t.right, x);<br></br>}<br></br>find(root, x);<br></br>`The described algorithm works correctly if the tree is binary search tree (i.e. for each node the values of left subtree are less than the value in the node, the values of right subtree are greater than the value in the node). But it can return invalid result if tree is not a binary search tree.
Since the given tree is not necessarily a binary search tree, not all numbers can be found this way. Your task is to calculate, how many times the search will fail being running on every value from the tree.
If the tree has multiple vertices with the same values on them then you should run algorithm on every one of them separately.</div>
<h2>输入输出格式</h2>
<h3>输入格式</h3>
<br />
<div>First line contains integer number $ n $ ( $ 1<=n<=10^{5} $ ) — number of vertices in the tree.
Each of the next $ n $ lines contains $ 3 $ numbers $ v $ , $ l $ , $ r $ ( $ 0<=v<=10^{9} $ ) — value on current vertex, index of the left child of the vertex and index of the right child of the vertex, respectively. If some child doesn't exist then number $ -1 $ is set instead. Note that different vertices of the tree may contain the same values.</div>
<h3>输出格式</h3>
<br />
<div>Print number of times when search algorithm will fail.</div>
<h2>输入输出样例</h2>
<h3>输入样例 #1</h3>
<pre><code>3
15 -1 -1
10 1 3
5 -1 -1
</code></pre>
<h3>输出样例 #1</h3>
<pre><code>2
</code></pre>
<h3>输入样例 #2</h3>
<pre><code>8
6 2 3
3 4 5
12 6 7
1 -1 8
4 -1 -1
5 -1 -1
14 -1 -1
2 -1 -1
</code></pre>
<h3>输出样例 #2</h3>
<pre><code>1
</code></pre>
<h2>说明</h2>
<div>In the example the root of the tree in vertex $ 2 $ . Search of numbers $ 5 $ and $ 15 $ will return fail because on the first step algorithm will choose the subtree which doesn't contain numbers you are looking for.</div>
</article>
</div>
</div>
</body>
</html>
