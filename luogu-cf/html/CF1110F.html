<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Nearest Leaf - 洛谷</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="renderer" content="webkit">
<meta name="csrf-token" content="1573401847:yA/hHtc0nQ6J4IvnOpN1h0MXzHMfj3RGtADNwQwixvw=">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" media="screen"/>
<link rel="stylesheet" href="https://cdn.luogu.com.cn/fe/loader.css?ver=20191106">
<script>window._feInjection = JSON.parse(decodeURIComponent("%7B%22code%22%3A200%2C%22currentTemplate%22%3A%22ProblemShow%22%2C%22currentData%22%3A%7B%22problem%22%3A%7B%22background%22%3A%22%22%2C%22description%22%3A%22Let%27s%20define%20the%20Eulerian%20traversal%20of%20a%20tree%20%28a%20connected%20undirected%20graph%20without%20cycles%29%20as%20follows%3A%20consider%20a%20depth-first%20search%20algorithm%20which%20traverses%20vertices%20of%20the%20tree%20and%20enumerates%20them%20in%20the%20order%20of%20visiting%20%28only%20the%20first%20visit%20of%20each%20vertex%20counts%29.%20This%20function%20starts%20from%20the%20vertex%20number%20%24%201%20%24%20and%20then%20recursively%20runs%20from%20all%20vertices%20which%20are%20connected%20with%20an%20edge%20with%20the%20current%20vertex%20and%20are%20not%20yet%20visited%20in%20increasing%20numbers%20order.%20Formally%2C%20you%20can%20describe%20this%20function%20using%20the%20following%20pseudocode%3A%5Cn%5Cn%60%60%60%5Cn%3Cbr%3E%3C%5C%2Fbr%3Enext_id%20%3D%201%3Cbr%3E%3C%5C%2Fbr%3Eid%20%3D%20array%20of%20length%20n%20filled%20with%20-1%3Cbr%3E%3C%5C%2Fbr%3Evisited%20%3D%20array%20of%20length%20n%20filled%20with%20false%3Cbr%3E%3C%5C%2Fbr%3E%3Cbr%3E%3C%5C%2Fbr%3Efunction%20dfs%28v%29%3A%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20visited%5Bv%5D%20%3D%20true%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20id%5Bv%5D%20%3D%20next_id%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20next_id%20%2B%3D%201%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20for%20to%20in%20neighbors%20of%20v%20in%20increasing%20order%3A%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20if%20not%20visited%5Bto%5D%3A%3Cbr%3E%3C%5C%2Fbr%3E%20%20%20%20%20%20%20%20%20%20%20%20dfs%28to%29%3Cbr%3E%3C%5C%2Fbr%3E%5Cn%60%60%60%5Cn%5CnYou%20are%20given%20a%20weighted%20tree%2C%20the%20vertices%20of%20which%20were%20enumerated%20with%20integers%20from%20%24%201%20%24%20to%20%24%20n%20%24%20using%20the%20algorithm%20described%20above.%5Cn%5CnA%20leaf%20is%20a%20vertex%20of%20the%20tree%20which%20is%20connected%20with%20only%20one%20other%20vertex.%20In%20the%20tree%20given%20to%20you%2C%20the%20vertex%20%24%201%20%24%20is%20not%20a%20leaf.%20The%20distance%20between%20two%20vertices%20in%20the%20tree%20is%20the%20sum%20of%20weights%20of%20the%20edges%20on%20the%20simple%20path%20between%20them.%5Cn%5CnYou%20have%20to%20answer%20%24%20q%20%24%20queries%20of%20the%20following%20type%3A%20given%20integers%20%24%20v%20%24%20%2C%20%24%20l%20%24%20and%20%24%20r%20%24%20%2C%20find%20the%20shortest%20distance%20from%20vertex%20%24%20v%20%24%20to%20one%20of%20the%20leaves%20with%20indices%20from%20%24%20l%20%24%20to%20%24%20r%20%24%20inclusive.%22%2C%22inputFormat%22%3A%22The%20first%20line%20contains%20two%20integers%20%24%20n%20%24%20and%20%24%20q%20%24%20%28%20%24%203%20%5C%5Cleq%20n%20%5C%5Cleq%20500%5C%5C%2C000%2C%201%20%5C%5Cleq%20q%20%5C%5Cleq%20500%5C%5C%2C000%20%24%20%29%20%5Cu2014%20the%20number%20of%20vertices%20in%20the%20tree%20and%20the%20number%20of%20queries%2C%20respectively.%5Cn%5CnThe%20%24%20%28i%20-%201%29%20%24%20-th%20of%20the%20following%20%24%20n%20-%201%20%24%20lines%20contains%20two%20integers%20%24%20p_i%20%24%20and%20%24%20w_i%20%24%20%28%20%24%201%20%5C%5Cleq%20p_i%20%3C%20i%2C%201%20%5C%5Cleq%20w_i%20%5C%5Cleq%2010%5E9%20%24%20%29%2C%20denoting%20an%20edge%20between%20vertices%20%24%20p_i%20%24%20and%20%24%20i%20%24%20with%20the%20weight%20%24%20w_i%20%24%20.%5Cn%5CnIt%27s%20guaranteed%20that%20the%20given%20edges%20form%20a%20tree%20and%20the%20vertices%20are%20enumerated%20in%20the%20Eulerian%20traversal%20order%20and%20that%20the%20vertex%20with%20index%20%24%201%20%24%20is%20not%20a%20leaf.%5Cn%5CnThe%20next%20%24%20q%20%24%20lines%20describe%20the%20queries.%20Each%20of%20them%20contains%20three%20integers%20%24%20v_i%20%24%20%2C%20%24%20l_i%20%24%20%2C%20%24%20r_i%20%24%20%28%20%24%201%20%5C%5Cleq%20v_i%20%5C%5Cleq%20n%2C%201%20%5C%5Cleq%20l_i%20%5C%5Cleq%20r_i%20%5C%5Cleq%20n%20%24%20%29%2C%20describing%20the%20parameters%20of%20the%20query.%20It%20is%20guaranteed%20that%20there%20is%20at%20least%20one%20leaf%20with%20index%20%24%20x%20%24%20such%20that%20%24%20l_i%20%5C%5Cleq%20x%20%5C%5Cleq%20r_i%20%24%20.%22%2C%22outputFormat%22%3A%22Output%20%24%20q%20%24%20integers%20%5Cu2014%20the%20answers%20for%20the%20queries%20in%20the%20order%20they%20are%20given%20in%20the%20input.%22%2C%22samples%22%3A%5B%5B%225%203%5Cn1%2010%5Cn1%201%5Cn3%202%5Cn3%203%5Cn1%201%205%5Cn5%204%205%5Cn4%201%202%5Cn%22%2C%223%5Cn0%5Cn13%5Cn%22%5D%2C%5B%225%203%5Cn1%201000000000%5Cn2%201000000000%5Cn1%201000000000%5Cn1%201000000000%5Cn3%204%205%5Cn2%201%205%5Cn2%204%205%5Cn%22%2C%223000000000%5Cn1000000000%5Cn2000000000%5Cn%22%5D%2C%5B%2211%208%5Cn1%207%5Cn2%201%5Cn1%2020%5Cn1%202%5Cn5%206%5Cn6%202%5Cn6%203%5Cn5%201%5Cn9%2010%5Cn9%2011%5Cn5%201%2011%5Cn1%201%204%5Cn9%204%208%5Cn6%201%204%5Cn9%207%2011%5Cn9%2010%2011%5Cn8%201%2011%5Cn11%204%205%5Cn%22%2C%228%5Cn8%5Cn9%5Cn16%5Cn9%5Cn10%5Cn0%5Cn34%5Cn%22%5D%5D%2C%22hint%22%3A%22In%20the%20first%20example%2C%20the%20tree%20looks%20like%20this%3A%5Cn%5Cn%20%21%5B%5D%28https%3A%5C%2F%5C%2Fcdn.luogu.com.cn%5C%2Fupload%5C%2Fvjudge_pic%5C%2FCF1110F%5C%2F0f1b498aea8daedc270520f6cae94d5c4aa241fe.png%29In%20the%20first%20query%2C%20the%20nearest%20leaf%20for%20the%20vertex%20%24%201%20%24%20is%20vertex%20%24%204%20%24%20with%20distance%20%24%203%20%24%20.%20In%20the%20second%20query%2C%20the%20nearest%20leaf%20for%20vertex%20%24%205%20%24%20is%20vertex%20%24%205%20%24%20with%20distance%20%24%200%20%24%20.%20In%20the%20third%20query%20the%20nearest%20leaf%20for%20vertex%20%24%204%20%24%20is%20vertex%20%24%204%20%24%20%3B%20however%2C%20it%20is%20not%20inside%20interval%20%24%20%5B1%2C%202%5D%20%24%20of%20the%20query.%20The%20only%20leaf%20in%20interval%20%24%20%5B1%2C%202%5D%20%24%20is%20vertex%20%24%202%20%24%20with%20distance%20%24%2013%20%24%20from%20vertex%20%24%204%20%24%20.%22%2C%22provider%22%3A%7B%22uid%22%3A3%2C%22name%22%3A%22%5Cu6d1b%5Cu8c37%22%2C%22slogan%22%3A%22%22%2C%22badge%22%3A%22%22%2C%22isAdmin%22%3Atrue%2C%22color%22%3A%22Purple%22%2C%22ccfLevel%22%3A0%7D%2C%22canEdit%22%3Afalse%2C%22limits%22%3A%7B%22time%22%3A%5B4000%5D%2C%22memory%22%3A%5B512000%5D%7D%2C%22stdCode%22%3A%22%22%2C%22vjudge%22%3A%7B%22origin%22%3A%22CodeForces%22%2C%22link%22%3A%22http%3A%5C%2F%5C%2Fcodeforces.com%5C%2Fproblemset%5C%2Fproblem%5C%2F1110%5C%2FF%22%2C%22id%22%3A%221110F%22%7D%2C%22translation%22%3A%22%5Cu7ed9%5Cu5b9a%5Cu4e00%5Cu68f5%5Cu4ee51%20%5Cu4e3a%5Cu6839%5Cu7684n%5Cu4e2a%5Cu8282%5Cu70b9%5Cu6709%5Cu6839%5Cu6811%5Cn%5Cn1%5Cu4e0d%5Cu662f%5Cu53f6%5Cu5b50%5Cn%5Cn%5Cu7ed9%5Cu5b9am%5Cu6b21%5Cu8be2%5Cu95ee%5Cn%5Cn%5Cu5f62%5Cu5982%20v%20l%20r%5Cn%5Cn%5Cu8f93%5Cu51fa%5Cu4ee5v%5Cu4e3a%5Cu8d77%5Cu70b9%20%5Cu7ec8%5Cu70b9%5Cu7f16%5Cu53f7%5Cu4e3al%20-%20r%5Cu4ee5%5Cu5185%5Cu7684%5Cu53f6%5Cu5b50%5Cu4e2d%20v%5Cu5230%5Cu53f6%5Cu5b50%5Cu6700%5Cu8fd1%5Cu7684%5Cu8ddd%5Cu79bb%5Cn%5Cn%2A%2A%5Cu6ce8%5Cu610f%5Cuff1a%5Cu5982%5Cu679c%5Cu6211%5Cu4eec%20DFS%20%5Cu8fd9%5Cu68f5%5Cu6811%5Cuff0c%5Cu5bf9%5Cu4e8e%5Cu6bcf%5Cu4e2a%5Cu70b9%5Cu90fd%5Cu9012%5Cu589e%5Cu679a%5Cu4e3e%5Cu513f%5Cu5b50%5Cu8282%5Cu70b9%5Cuff0c%5Cu6bcf%5Cu8bbf%5Cu95ee%5Cu5230%5Cu4e00%5Cu4e2a%5Cu8282%5Cu70b9%5Cu5c31%5Cu8bb0%5Cu5f55%5Cu5176%5Cu7f16%5Cu53f7%5Cuff0c%5Cu90a3%5Cu4e48%5Cu5f97%5Cu5230%5Cu7684%5Cu5e8f%5Cu5217%5Cu521a%5Cu597d%5Cu4e3a%201%20%5Cu5230%20n%5Cu3002%2A%2A%22%2C%22tags%22%3A%5B%5D%2C%22wantsTranslation%22%3Afalse%2C%22totalSubmit%22%3A212%2C%22totalAccepted%22%3A103%2C%22pid%22%3A%22CF1110F%22%2C%22title%22%3A%22Nearest%20Leaf%22%2C%22difficulty%22%3A7%2C%22type%22%3A%22CF%22%7D%2C%22contest%22%3Anull%2C%22discussions%22%3A%5B%7B%22id%22%3A98854%2C%22title%22%3A%22%5Cu7ffb%5Cu8bd1%5Cu6709%5Cu8bef%5Cuff1f%22%2C%22forum%22%3A%7B%22id%22%3A34162%2C%22name%22%3A%22CF1110F%20Nearest%20Leaf%22%2C%22slug%22%3A%22CF1110F%22%7D%7D%5D%2C%22bookmarked%22%3Afalse%2C%22vjudgeUsername%22%3Anull%2C%22recommendations%22%3A%5B%7B%22pid%22%3A%22CF1101F%22%2C%22title%22%3A%22Trucks%20and%20Cities%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF1110G%22%2C%22title%22%3A%22Tree-Tac-Toe%20%22%2C%22difficulty%22%3A7%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF1110E%22%2C%22title%22%3A%22Magic%20Stones%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF1110D%22%2C%22title%22%3A%22Jongmah%22%2C%22difficulty%22%3A6%2C%22type%22%3A%22CF%22%7D%2C%7B%22pid%22%3A%22CF1209E2%22%2C%22title%22%3A%22Rotate%20Columns%20%28hard%20version%29%22%2C%22difficulty%22%3A0%2C%22type%22%3A%22CF%22%7D%5D%2C%22lastLanguage%22%3A%22%22%2C%22lastCode%22%3A%22%22%7D%2C%22currentTitle%22%3A%22Nearest%20Leaf%22%2C%22currentTheme%22%3Anull%7D"));window._feConfigVersion=1572920822;</script>
<script src="https://cdn.luogu.com.cn/fe/loader.js?ver=20191106" charset="utf-8" defer></script>
</head>
<body>
<div id="app">
<div class="lg-container">
<article>
<h1>Nearest Leaf</h1>
<h2>题意翻译</h2>
<div>给定一棵以1 为根的n个节点有根树
1不是叶子
给定m次询问
形如 v l r
输出以v为起点 终点编号为l - r以内的叶子中 v到叶子最近的距离
**注意：如果我们 DFS 这棵树，对于每个点都递增枚举儿子节点，每访问到一个节点就记录其编号，那么得到的序列刚好为 1 到 n。**</div>
<h2>题目描述</h2>
<div>Let's define the Eulerian traversal of a tree (a connected undirected graph without cycles) as follows: consider a depth-first search algorithm which traverses vertices of the tree and enumerates them in the order of visiting (only the first visit of each vertex counts). This function starts from the vertex number $ 1 $ and then recursively runs from all vertices which are connected with an edge with the current vertex and are not yet visited in increasing numbers order. Formally, you can describe this function using the following pseudocode:
```
<br></br>next_id = 1<br></br>id = array of length n filled with -1<br></br>visited = array of length n filled with false<br></br><br></br>function dfs(v):<br></br> visited[v] = true<br></br> id[v] = next_id<br></br> next_id += 1<br></br> for to in neighbors of v in increasing order:<br></br> if not visited[to]:<br></br> dfs(to)<br></br>
```
You are given a weighted tree, the vertices of which were enumerated with integers from $ 1 $ to $ n $ using the algorithm described above.
A leaf is a vertex of the tree which is connected with only one other vertex. In the tree given to you, the vertex $ 1 $ is not a leaf. The distance between two vertices in the tree is the sum of weights of the edges on the simple path between them.
You have to answer $ q $ queries of the following type: given integers $ v $ , $ l $ and $ r $ , find the shortest distance from vertex $ v $ to one of the leaves with indices from $ l $ to $ r $ inclusive.</div>
<h2>输入输出格式</h2>
<h3>输入格式</h3>
<br />
<div>The first line contains two integers $ n $ and $ q $ ( $ 3 \leq n \leq 500\,000, 1 \leq q \leq 500\,000 $ ) — the number of vertices in the tree and the number of queries, respectively.
The $ (i - 1) $ -th of the following $ n - 1 $ lines contains two integers $ p_i $ and $ w_i $ ( $ 1 \leq p_i < i, 1 \leq w_i \leq 10^9 $ ), denoting an edge between vertices $ p_i $ and $ i $ with the weight $ w_i $ .
It's guaranteed that the given edges form a tree and the vertices are enumerated in the Eulerian traversal order and that the vertex with index $ 1 $ is not a leaf.
The next $ q $ lines describe the queries. Each of them contains three integers $ v_i $ , $ l_i $ , $ r_i $ ( $ 1 \leq v_i \leq n, 1 \leq l_i \leq r_i \leq n $ ), describing the parameters of the query. It is guaranteed that there is at least one leaf with index $ x $ such that $ l_i \leq x \leq r_i $ .</div>
<h3>输出格式</h3>
<br />
<div>Output $ q $ integers — the answers for the queries in the order they are given in the input.</div>
<h2>输入输出样例</h2>
<h3>输入样例 #1</h3>
<pre><code>5 3
1 10
1 1
3 2
3 3
1 1 5
5 4 5
4 1 2
</code></pre>
<h3>输出样例 #1</h3>
<pre><code>3
0
13
</code></pre>
<h3>输入样例 #2</h3>
<pre><code>5 3
1 1000000000
2 1000000000
1 1000000000
1 1000000000
3 4 5
2 1 5
2 4 5
</code></pre>
<h3>输出样例 #2</h3>
<pre><code>3000000000
1000000000
2000000000
</code></pre>
<h3>输入样例 #3</h3>
<pre><code>11 8
1 7
2 1
1 20
1 2
5 6
6 2
6 3
5 1
9 10
9 11
5 1 11
1 1 4
9 4 8
6 1 4
9 7 11
9 10 11
8 1 11
11 4 5
</code></pre>
<h3>输出样例 #3</h3>
<pre><code>8
8
9
16
9
10
0
34
</code></pre>
<h2>说明</h2>
<div>In the first example, the tree looks like this:
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1110F/0f1b498aea8daedc270520f6cae94d5c4aa241fe.png)In the first query, the nearest leaf for the vertex $ 1 $ is vertex $ 4 $ with distance $ 3 $ . In the second query, the nearest leaf for vertex $ 5 $ is vertex $ 5 $ with distance $ 0 $ . In the third query the nearest leaf for vertex $ 4 $ is vertex $ 4 $ ; however, it is not inside interval $ [1, 2] $ of the query. The only leaf in interval $ [1, 2] $ is vertex $ 2 $ with distance $ 13 $ from vertex $ 4 $ .</div>
</article>
</div>
</div>
</body>
</html>
