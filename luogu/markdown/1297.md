# [国家集训队]单选错位

## 题目背景

原 《网线切割》请前往P1577

## 题目描述

gx和lc去参加noip初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。试卷上共有n道单选题，第i道单选题有ai个选项，这ai个选项编号是1,2,3,…,ai，每个选项成为正确答案的概率都是相等的。lc采取的策略是每道题目随机写上1-ai的某个数作为答案选项，他用不了多少时间就能期望做对$\sum_{i=1}^n \frac{1}{a_i}$道题目。gx则是认认真真地做完了这n道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第i道题目的答案抄到了答题纸上的第i+1道题目的位置上，特别地，第n道题目的答案抄到了第1道题目的位置上。现在gx已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被lc鄙视了。

我们假设gx没有做错任何题目，只是答案抄错位置了。

## 输入输出格式

### 输入格式

n很大，为了避免读入耗时太多，输入文件只有5个整数参数n, A, B, C, a1，由上交的程序产生数列a。下面给出pascal/C/C++的读入语句和产生序列的语句（默认从标准输入读入）：

```cpp

// for pascal

readln(n,A,B,C,q[1]);

for i:=2 to n do

q[i] := (int64(q[i-1]) * A + B) mod 100000001;

for i:=1 to n do

q[i] := q[i] mod C + 1;

// for C/C++

scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);

for (int i=2;i<=n;i++)

a[i] = ((long long)a[i-1] * A + B) % 100000001;

for (int i=1;i<=n;i++)

a[i] = a[i] % C + 1;

```

选手可以通过以上的程序语句得到n和数列a（a的元素类型是32位整数），n和a的含义见题目描述。

### 输出格式

输出一个实数，表示gx期望做对的题目个数，保留三位小数。

## 输入输出样例

### 输入样例 #1

```cpp
3 2 0 4 1
```


### 输出样例 #1

```cpp
1.167

```
## 说明

【样例说明】

```cpp

正确答案 | gx的答案 | 做对题目| 出现概率

{1,1,1} | {1,1,1} | 3 | 1/6

{1,2,1} | {1,1,2} | 1 | 1/6

{1,3,1} | {1,1,3} | 1 | 1/6

{2,1,1} | {1,2,1} | 1 | 1/6

{2,2,1} | {1,2,2} | 1 | 1/6

{2,3,1} | {1,2,3} | 0 | 1/6

```

a[] = {2,3,1}

共有6种情况，每种情况出现的概率是1/6，gx期望做对(3+1+1+1+1+0)/6 = 7/6题。（相比之下，lc随机就能期望做对11/6题）

对于30%的数据 n≤10, C≤10

对于80%的数据 n≤10000, C≤10

对于90%的数据 n≤500000, C≤100000000

对于100%的数据 2≤n≤10000000, 0≤A,B,C,a1≤100000000

